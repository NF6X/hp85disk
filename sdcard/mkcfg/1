/// ===========================================================
///@brief hpdir.ini file processing

///@brief Init Disk Parameter Structure
///
/// This structure will containes the parsed and computed
/// disk parameters from a single hpdir disk entry
///
///@return void
void hpdir_init()
{
    memset(hpdir.model,0,sizeof(hpdir.model) -1);		// 1
    memset(hpdir.comment,0,sizeof(hpdir.comment) -1);	// 2
    memset(hpdir.TYPE,0,sizeof(hpdir.TYPE) -1);		// 3
    hpdir.ID = 0;						// 4
	hpdir.mask_stat2 = 0;				// 5
	hpdir.id_stat2 = 0;					// 6
	hpdir.DEVICE_NUMBER = 0;			// 7
	hpdir.UNITS_INSTALLED = 0x8001;		// 8
	hpdir.CYLINDERS = 0;  				// 9
	hpdir.HEADS= 0;	     				// 10
	hpdir.SECTORS= 0;    				// 11
	hpdir.BYTES_PER_BLOCK = 0;			// 12
	hpdir.INTERLEAVE = 0;				// 13
    hpdir.FIXED = 1;					// 14 ALWAYS 1

	// Computed values
    hpdir.BLOCKS = 0;
	hpdir.LIF_DIR_BLOCKS= 0;
}


// =============================================
///@brief LIF Directory blocks ~= sqrt(blocks);
///
/// We simplify 
///  BITS = MSB bit number of block count 
///  Directory size = BITS / 2
///@param[in] blocks: size of LIF image in total
///
///@return Size of LIF directory in blocks
long lif_dir_count(long blocks)
{
	int scale = 0;
	long num = 1;
	while(blocks)
	{
		scale++;
 		blocks >>= 1;
	}
	scale>>=1;
	while(scale--)
		num <<=1;
	return(num);
}

/// ===============================================
///@brief Find drive parameters in hpdir.ini file
///
///@param[in] model: model string
///
///@return 1 on sucess or 0 on fail
bool hpdir_find_drive(char *model)
{
    int len;
    uint32_t val;
    int errors = 0;
    int driveinfo=0;
    int found = 0;
	FILE *cfg;
	char *ptr;
    char str[256];
    char token[128];

	hpdir_init();

	cfg = fopen("/hpdir.ini","rb");
	if(cfg == NULL)
	{
		printf("Error: /hpdir.ini not found!\n");
		return;
	}
	//printf("Searching /hpdir.ini for model:%s\n", model);

    while( (ptr = fgets(str, sizeof(str)-2, cfg)) != NULL)
    {
		errors = 0;
        ptr = str;

        trim_tail(ptr);
        ptr = skipspaces(ptr);

        len = strlen(ptr);
        if(!len)
            continue;

        // Skip comments
        if(*ptr == ';' || *ptr == '#' )
            continue;

		if(*ptr == '[' && driveinfo == 1 )
                break;

		// MODEL something else
		ptr = get_token(ptr, token, 	sizeof(token)-2);

        if(MATCHI(token,"[driveinfo]"))
        {
			driveinfo = 1;
            continue;
        }

		if( driveinfo != 1)
			continue;

		if ( ! MATCHI(model,token) )
			continue;

		hpdir_init();
		printf("Found Model: %s\n", model);

		strncpy(hpdir.model,token,sizeof(hpdir.model)-2);				// 1 Model

		ptr = get_token(ptr, token, 	sizeof(token)-2);				// =

		ptr = get_token(ptr, hpdir.comment, sizeof(hpdir.comment)-2);	// 2 Comment

		ptr = get_token(ptr, hpdir.TYPE,  sizeof(hpdir.TYPE)-2);		// 3 AMIGO/SS80/CS80

		ptr = get_token(ptr, token, 		sizeof(token)-2);			// 4 Identify ID
		if (!assign_value(token, 0, 0xFFFFUL, &val) )
			++errors;
		hpdir.ID = val;

		ptr = get_token(ptr, token, 		sizeof(token)-2);			// 5 MASK STAT 2
		if (!assign_value(token, 0, 0xFFUL, &val) )
			++errors;
		hpdir.mask_stat2 = val;

		ptr = get_token(ptr, token, 		sizeof(token)-2);			// 6 STAT2
		if (!assign_value(token, 0, 0xFFUL, &val) )
			++errors;
		hpdir.id_stat2 = val;				// 6

		ptr = get_token(ptr, token, 		sizeof(token)-2);			// 7 BCD include model number
		if (!assign_value(token, 0, 0xffffffffUL, &val) )
			++errors;
		hpdir.DEVICE_NUMBER = val;

		ptr = get_token(ptr, token, 		sizeof(token)-2);			// 8 Units installed
		if (!assign_value(token, 0, 8, &val) )
			++errors;
		hpdir.UNITS_INSTALLED = val;

		ptr = get_token(ptr, token, 		sizeof(token)-2);			// 9 Cylinders
		if (!assign_value(token, 0, 0x00ffffffUL, &val) )
			++errors;
		// Token is CYLINDERS, MAX_CYLINDER = CYLINDERS -1
		hpdir.CYLINDERS = val;	

		ptr = get_token(ptr, token, 		sizeof(token)-2);			// 10 Heads
		if (!assign_value(token, 0, 0xffffUL, &val) )
			++errors;
		// Token is HEADS, MAX_HEAD = HEADS -1
		hpdir.HEADS = val;

		ptr = get_token(ptr, token, 		sizeof(token)-2);			// 11 Sectors
		if (!assign_value(token, 0, 0xffffUL, &val) )
			++errors;
		// Token is SECTORS, MAX_SECTOR = SECTORS -1
		hpdir.SECTORS = val;

		ptr = get_token(ptr, token, 		sizeof(token)-2);			// 12 Bytes Per Block/Sector
		if (!assign_value(token, 0, 0xffffUL, &val) )
			++errors;
		hpdir.BYTES_PER_BLOCK = val;

		ptr = get_token(ptr, token, 		sizeof(token)-2);			// 13 Interleave
		if (!assign_value(token, 0, 0xffffUL, &val) )
			++errors;
		hpdir.INTERLEAVE = val;

		// Computed values
		hpdir.BLOCKS = ( hpdir.CYLINDERS * hpdir.HEADS * hpdir.SECTORS );
		hpdir.LIF_DIR_BLOCKS = lif_dir_count(hpdir.BLOCKS);

		if(errors)
		{
			printf("Error /hpdir.ini parsing\n");
			break;
		}
		found = 1;
		break;

	}	// while
	fclose(cfg);
	// printf("Done /hpdir.ini\n\n");
	return(found);
}

