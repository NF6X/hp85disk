void trim_tail(char *str)
{
    int len = strlen(str);
    while(len--)
    {
        if(str[len] > ' ')
            break;
        str[len] = 0;
    }
}

char *skipspaces(char *ptr)
{
    if(!ptr)
        return(ptr);

    while(*ptr == ' ' || *ptr == '\t')
        ++ptr;
    return(ptr);
}


// =============================================
///@brief Compare two strings without case.
///
///@param[in] str: string to match.
///@param[in] pat: pattern to compare.
///
///@return string lenth on match.
///@return 0 on no match.
int MATCHI(char *str, char *pat)
{
    int len;
    len = strlen(pat);
    if(strcasecmp(str,pat) == 0 )
        return(len);
    return(0);
}
// =============================================
///@brief Compare two strings limted to length of pattern.
///
///@param[in] str: string to match.
///@param[in] pat: pattern to compare.
///
///@return string lenth on match.
///@return 0 on no match.
///@warning Matches sub strings so be caeful.
int MATCH_LEN(char *str, char *pat)
{
    int len;

    if(!str || !pat)
        return(0);
    len = strlen(pat);

    if( len )
    {
        if(strncmp(str,pat,len) == 0 )
            return(len);
    }
    return(0);
}

// =============================================
///@brief Compare two strings without case limted to length of pattern.
///
///@param[in] str: string to match.
///@param[in] pat: pattern to compare.
///
///@return string lenth on match.
///@return 0 on no match.
///@warning Matches sub strings so be caeful.
int MATCHI_LEN(char *str, char *pat)
{
    int len;

    if(!str || !pat)
        return(0);
    len = strlen(pat);

    if( len )
    {
        if(strncasecmp(str,pat,len) == 0 )
            return(len);
    }
    return(0);
}

/// @brief get a number
///
/// - Used only for debugging
/// @param[in] str: string to examine
///
/// @return  value
int32_t get_value(char *str)
{
    int base;
    int ret;
    char *ptr;
    char *endptr;


    ptr = skipspaces(str);
    base = 10;

    // convert number base 10, 16, 8 and 2
    if( (ret = MATCHI_LEN(ptr,"0x")) )
    {
        base = 16;
        ptr += ret;
    }
    else if( (ret = MATCHI_LEN(ptr,"0o")) )
    {
        base = 8;
        ptr += ret;
    }
    else if( (ret = MATCHI_LEN(ptr,"0b")) )
    {
        base = 2;
        ptr += ret;
    }
    return(strtol(ptr, (char **)&endptr, base));
}



/// @brief assigned a value
///
/// - Used only for debugging
/// @param[in] str: string to examine
/// @param[in] minval: minimum value
/// @param[in] maxval: maximum value
/// @param[in] *val: value to set
///
/// @return  1 is matched and value in range, 0 not matched or out of range
uint32_t assign_value(char *str, uint32_t minval, uint32_t maxval, uint32_t *val)
{
    uint32_t tmp;
    int bad = 0;
    char *ptr;

    // Skip spaces before assignment
    ptr = skipspaces(str);
    // Skip optional '='
    if(*ptr == '=')
    {
        ++ptr;
        // skip spaces after assignment
        ptr = skipspaces(ptr);
    }
    if(!*ptr)
    {
		printf(":%s missing value\n", str);
        bad = 1;
    }
    if(!bad)
    {
        // FIXME detect bad numbers
        tmp = get_value(ptr);
        *val = tmp;
        if((minval && (tmp < minval)))
        {
            printf("%s is below range %d\n", ptr,(int)minval);
            bad = 1;
        }
        if((maxval != 0xffffffffUL) && (tmp > maxval))
        {
            printf("%s is above range %d\n", ptr,(int)maxval);
            bad = 1;
        }
    }
    if(bad)
        return(0);
    return(1);
}

// =============================================
///@brief return next token
///
/// - Skips all non printable ASCII characters before token
/// - Token returns only printable ASCII
///
///@param[in] str: string to search.
///@param[out] token: token to return
///@param[in] max: maximum token size
///
///@return pointer past token on success .
///@return NULL if no token found
char *get_token(char *str, char *token, int max)
{
    if(!str)
        return(str);

    // Skip beginning spaces
    str = skipspaces(str);
    // Delete all trailing spaces
    trim_tail(str);

    while(*str > ' ' && max > 0) {

        // String processing
        // A token can be a quoted string
        if(*str == '"')
        {
            ++str;
            // We are pointing at the body of the quoted string now
            while(*str && *str != '"' && max > 0)
            {
                *token++ = *str++;
                --max;
            }
            if(*str == '"')
            {
                ++str;
                *token++ = 0;
                --max;
                break;
            }
            break;
        }

        // If we have a comma, break
        if(*str == ',' )
			break;

        // copy token
        *token++ = *str++;
        --max;
    }

    // Skip trailing spaces
    str = skipspaces(str);
    // If we had a trailing comma skip it
    if(*str == ',' )
        ++str;

    *token = 0;
    return(str);
}
